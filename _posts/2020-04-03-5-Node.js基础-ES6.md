---
layout:     post
title:      Node.js基础-ES6
subtitle:   ES6 部分功能介绍
date:       2020-04-03
author:     BY
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - Node
    - ES6
---


# ES6 部分功能介绍

####     `let` 和 `const` 的使用规范

1.  **let**
               -  与`var`不同，`let`和`const`都是模块化的，必须先声明定义后，才能使用。
                          - `let`声明的变量不允许重复，在同一个作用域内部。
                          - 外部作用域，不能访问内部作用域的`let`；
                                     - for 循环括号中声明的变量只能在循环体中使用。
                                     - 块级作用域内部，变量只能先声明后使用

2.  **const**
    - `const`用来声明常量。
    - `const`声明的常量不允许重新复制
    - `const`声明的常量必须初始化，就是说必需给赋值。

####     变量的结构赋值

   1. 数组的解构赋值

      `let [ a, b, c ] = [ 1, 2, 3 ]` 相当于  `let a = 1; let b = 2; let c = 3`

      - 注意：左边的数组中，顺序不同，解构后对应的数据也会发生改变。

2. 对象的解构赋值

   `let { a, b, c } = { a: 1, b: 2, c: 3}`

   - 注意： 这样解构的的属性，必须是存在于被解构的对象中的

   - 当然也是可以重新命名的 `let { a, b:d, c} = { a: 1, b: 2, c: 3}`    此时用的话就没有`b`这个变量 只有`d`这个变量，就是起了一个别名。

   - 左边的对象中，顺序是没有什么影响的，可以打乱。

   - 只要是一个对象`{}`都是可以被解构的， 像`JS`的内置对象 `Math`,  `Date`都是可以进行解构赋值。

     

3. 字符串的解构赋值

   `let [a, b ,c ,d ,e] = "hello"` 相当于 `let a= "h":let b = "e"; let c ="l";...`依次对应

   - 可以利用对象赋值的方式用于字符串的 `let { length } = "hello"`; 可以直接拿到字符串的长度。

####       字符串的扩展

1. `includes()`

   - 用于寻找字符串中，有没有包含某个字符串 `includes('xxx')`； 

   - 参数1： 要匹配的字符串， 参数2：从第几个开始匹配。

     

2. `startsWith()`

   - 判断字符串是不是以特定的字符串开始。

3. `endWith()`

   - 判断字符串是不是以特定的字符串结尾。

4. 模板字符串

   - 就是以   " ``" 两个撇包含在呢的字符串，或者html等 json
   - 变量在其中以`${xxx}`的方式进行引入就可以了。

#### 函数的相关扩展

1. 参数默认值

   - 其实就是给函数的形参，直接等于一个值，这个的意思就是，当没传递值的时候，这个形参就是这个默认值，如果传参了，就是传参的值。

     `function(params = 123){};`

2. 参数的解构赋值

   - 这个就是例如如果传入的参数是一个对象，那么在函数的形参里，可以将传入进来的对象进行解构。

     `function ({ name, id }){};`

3. 其余参数， rest参数

   - 比如传递给函数的参数很多，我们就可以利用rest参数，接收除了前面设置好的参数外的其余参数

     `funtion (a1, a2, ...rest){};`  `rest`拿到的就是除了`a1, a2`之外所有的参数了。

4. ...扩展运算符

   - 就是传给给函数的参数，例如数组，可以`...arr`的方式，将数组的内容，打散开传入给函数。

     `var arr = [ 1, 2, 3, 4, 5 ];`  

     `function (...arr){}`

   - 可以合并数组 `let arr3 = [...arr1, ...arr2 ]`              

5. 箭头函数

   - `let foo = (v) => v`

   - 当内部是直接`return`的时候，`return`是可以省略的

   - 箭头函数内部的`this`指向父级，如果父级还是箭头函数，则继续往上，知道找到对应的`this`

   - 注意：

     - 箭头函数中的`this`取决于函数的定义， 而不是调用。

     - 箭头函数不能使用`new`方法。

     - 箭头函数不能是用`arrguments`来获取参数列表,   可以使用`rest`参数代替

       `let foo = (...params) { console.log(params)}`

#### 类和继承

   1. `es6`的类实现方法就是语法糖class

      ```
      class Animal {
         //静态方法 只能通过类名调用 
             static  showInfo () {}`  
              constructor(name){
                  this.name = name`
               }
      }
      ```

      

2. 类的继承 关键字 `extends`

   ```
   2. class Dog extends Animal {
             constructor(name){
               super(name)
           }
      }
   ```

   

3. 最后 `let dog = new Dog("123")`

4. 静态方法的继承，就直接继承过来了，`Dog`可以直接使用`showInfo`     `Dog.showInfo()`